{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor L1 = motor(PORT20, ratio6_1, true);\n\nmotor L2 = motor(PORT19, ratio6_1, true);\n\nmotor L3 = motor(PORT18, ratio6_1, true);\n\nmotor R1 = motor(PORT16, ratio6_1, false);\n\nmotor R2 = motor(PORT15, ratio6_1, false);\n\nmotor R3 = motor(PORT14, ratio6_1, false);\n\ncontroller Controller1 = controller(primary);\nmotor intake = motor(PORT17, ratio18_1, true);\n\ndigital_out holder = digital_out(Brain.ThreeWirePort.A);\ninertial Inertial21 = inertial(PORT21);\n\ndistance DistanceBack = distance(PORT8);\ndistance DistanceFront = distance(PORT12);\nmotor armL = motor(PORT2, ratio18_1, false);\n\ndigital_out grabber = digital_out(Brain.ThreeWirePort.B);\nrotation Rotation3 = rotation(PORT3, true);\n\ndistance DistanceLeft = distance(PORT9);\ndistance DistanceRight = distance(PORT7);\ndigital_out lift = digital_out(Brain.ThreeWirePort.G);\ndigital_out intakeLift = digital_out(Brain.ThreeWirePort.C);\ndigital_out endGame = digital_out(Brain.ThreeWirePort.F);\nline HD = line(Brain.ThreeWirePort.E);\nmotor intake2 = motor(PORT5, ratio18_1, true);\n\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       {author}                                                  */\n/*    Created:      {date}                                                    */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n/*\n  Copyright © 2024 Radiant Robotics LLC. All rights reserved.\n\n  This software is the proprietary property of Radiant Robotics LLC and Haotian Guo. \n\n  Unauthorized copying, reproduction, distribution, or public sharing of this software, \n  in whole or in part, is strictly prohibited without prior written permission from \n  Radiant Robotics LLC.\n\n  Commercial use, including but not limited to resale, sublicensing, or incorporation \n  into other products or services, is expressly forbidden without explicit written \n  authorization.\n\n  For licensing inquiries or permissions, please contact:\n  Radiant Robotics LLC\n  Email: radiantrobotics@gmail.com\n*/\n\n\n// Include the V5 Library\n#include \"vex.h\"\ncompetition Competition;\n\ndouble move_speed=0,move_speedl,move_speedr,turn_speed=0,SpeedLeft,SpeedRight,targetAngle=0;\ndouble tp=0.55,ti=0.0,td=-0.4;\nint turn_flag=1,drive_flag=1,arm_flag=0,grabber_flag=0; // 0red1blue\nint arm_target=0,arm_position=0,intake_speed = 0 ,intake2_speed = 0;\ndouble speedL, speedR , last_angle ;\ndouble dSpeedL = 0 , dSpeedR = 0;\nint armTakeRing = 40;\nint armWallStake = 165;\nint armAllianceStake = 255; \nint armLowest = 0;\nvoid displayThread()\n{\n  while(1)\n  {\n    wait(0.2,seconds);\n    Brain.Screen.clearLine(1);\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.print(\"abc\");\n  }\n}\nvoid armThread()\n{\n  double ae;  // 误差\n  double as = 0;\n  double akp = 3;  // P控制系数\n  intake.spin(forward);\n  while(1)\n  {\n    // if(drive_flag==1)\n    // {\n    //   if(intake_mode==0)\n    //   {\n    //     intake.setVelocity(0,percent);\n    //     intake2.setVelocity(0,percent);\n    //   }\n    //   else if(intake_mode==1)\n    //   {\n    //     intake.setVelocity(-100,percent);\n    //     intake2.setVelocity(-100,percent);\n    //   }\n    //   else if(intake_mode==2)\n    //   {\n    //     intake.setVelocity(30,percent);\n    //     intake2.setVelocity(30,percent);\n    //   }\n    //   else if(intake_mode==3)\n    //   {\n    //     intake.setVelocity(50,percent);\n    //     intake2.setVelocity(50,percent);\n    //   }\n    // }\n    intake.setVelocity(intake_speed,percent);\n    intake2.setVelocity(intake2_speed,percent);\n        // if (arm_flag == 0)\n        // {\n        //   arm_target = 40;\n        // }\n        // else if (arm_flag == 1)\n        // {\n        //   arm_target = 165;\n        // }\n        // else if(arm_flag == 2)\n        // {\n        //   arm_target = 255;\n        // }\n        // else if(arm_flag == 3)\n        // {\n        //   arm_target = 0;\n        // }\n        // else if(arm_flag == 4)\n        // {\n        //   arm_target = 145;\n        // }\n    arm_position = Rotation3.position(degrees);\n    if (abs(arm_position - arm_target) <= 1)\n    {\n      armL.setVelocity(0, percent);  // 使用低速保持电机力矩\n    }\n    else\n    {\n      ae = arm_target - arm_position;\n      as = ae * akp;\n      if (as > 100) as = 100;\n      if (as < -100) as = -100;\n      armL.setVelocity(as, percent);\n    }\n    wait(0.01, seconds);\n  }\n}\nvoid turnThread()\n{\n    double error_angle = 0;\n    double integral_angle = 0;\n    double differential_angle = 0;\n    double last_angle = Inertial21.heading(degrees);\n    double max_turn_speed = 50, min_turn_speed = -50;\n    double acc_speed = 5;\n    double current_speed_L = 0, current_speed_R = 0;\n    while (1)\n    {\n      if(turn_flag==0)\n      {\n        if(drive_flag==0)     \n        {\n          turn_speed=0;\n          SpeedLeft=move_speedl-turn_speed;\n          SpeedRight=move_speedr+turn_speed;\n          wait(0.05,seconds);\n          L1.setVelocity(SpeedLeft, percent);\n          L2.setVelocity(SpeedLeft, percent);\n          L3.setVelocity(SpeedLeft, percent);\n          R1.setVelocity(SpeedRight, percent);\n          R2.setVelocity(SpeedRight, percent);\n          R3.setVelocity(SpeedRight, percent);\n          continue;\n        }\n        else\n        {\n          wait(0.1,seconds);\n          continue;\n        }\n      }\n      wait(0.05, seconds);\n      error_angle = targetAngle - Inertial21.heading(degrees);\n      if (error_angle < -180) error_angle += 360;\n      if (error_angle > 180) error_angle -= 360;\n\n      integral_angle += error_angle;\n      if (fabs(error_angle) > 3) integral_angle = 0;\n\n      differential_angle = Inertial21.heading(degrees) - last_angle;\n      if (fabs(differential_angle) > 180) differential_angle = 0;\n\n      last_angle = Inertial21.heading(degrees);\n      turn_speed = tp * error_angle + ti * integral_angle + td * differential_angle;\n\n      if (turn_speed > max_turn_speed) turn_speed = max_turn_speed;\n      if (turn_speed < min_turn_speed) turn_speed = min_turn_speed;\n\n      double target_speed_L = move_speedl ;\n      double target_speed_R = move_speedr ;\n\n      if (target_speed_L > current_speed_L + acc_speed) \n      {\n        current_speed_L += acc_speed;\n      } \n      else if (target_speed_L < current_speed_L - acc_speed) \n      {\n        current_speed_L -= acc_speed;\n      } \n      else \n      {\n        current_speed_L = target_speed_L;\n      }\n\n      if (target_speed_R > current_speed_R + acc_speed) \n      {\n        current_speed_R += acc_speed;\n      } \n      else if (target_speed_R < current_speed_R - acc_speed) \n      {\n        current_speed_R -= acc_speed;\n      } \n      else \n      {\n        current_speed_R = target_speed_R;\n      }\n      L1.setVelocity(current_speed_L + turn_speed + dSpeedL, percent);\n      L2.setVelocity(current_speed_L + turn_speed + dSpeedL, percent);\n      L3.setVelocity(current_speed_L + turn_speed + dSpeedL, percent);\n      R1.setVelocity(current_speed_R - turn_speed + dSpeedR, percent);\n      R2.setVelocity(current_speed_R - turn_speed + dSpeedR, percent);\n      R3.setVelocity(current_speed_R - turn_speed + dSpeedR, percent);\n    }\n}\n\nvoid turn(int t_a,double t_t)\n{\n  targetAngle=t_a;\n  wait(t_t,seconds);\n}\n\nvoid move(double sl,double sr,double t)\n{\n  if(sl!=sr)\n  {\n    turn_flag=0;\n  }\n  move_speedl=sl;\n  move_speedr=sr;\n  wait(t,seconds);\n  move_speedl=0;\n  move_speedr=0;\n  if(sl!=sr)\n  {\n    turn_flag=1;\n  }\n}\nvoid just_move(double sl,double sr,double t)\n{\n  turn_flag=0;\n  move_speedl=sl;\n  move_speedr=sr;\n  wait(t,seconds);\n  move_speedl=0;\n  move_speedr=0;\n}\n\nvoid intake_(int s)\n{\n  intake.spin(forward);\n  intake2.spin(forward);\n  intake.setVelocity(-s,percent);\n  intake2.setVelocity(-s,percent);\n}\n\nvoid nottake_()\n{\n  intake.spin(forward);\n  intake2.spin(forward);\n  intake.setVelocity(0,percent);\n  intake2.setVelocity(0,percent);\n}\n\nvoid Driver()\n{ \n \n  double lx=0,ly=0,rx=0,ry=0;\n  turn_flag=0;\n  drive_flag=1;\n  int holder_flag=1;\n  int wallStake_flag = 0;\n  double maxSpeed=12;\n  bool intakeDone = false; \n  int endGame_flag=0;\n  while(1)\n  {\n    wait(0.02,seconds);\n    //======================  Drive  =======================//\n    lx=Controller1.Axis4.position();\n    ly=Controller1.Axis3.position();\n    rx=Controller1.Axis1.position();\n    ry=Controller1.Axis2.position();\n    move_speed=ly;\n    turn_speed=-rx*0.65;\n    //======================  End Game  =======================//\n    if(Controller1.ButtonUp.pressing())\n    {\n      endGame_flag=!endGame_flag;\n      while(Controller1.ButtonUp.pressing())\n      {\n        wait(0.01,seconds);\n      }\n    }\n    endGame.set(endGame_flag);\n    //======================  WallStake Mode  =======================//\n    if(Controller1.ButtonX.pressing())\n    {\n      wallStake_flag=!wallStake_flag;\n      while(Controller1.ButtonX.pressing())\n      {\n        wait(0.01,seconds);\n      }\n    }\n    //======================  Holder  =======================//\n    if(Controller1.ButtonL2.pressing())\n    {\n      holder_flag=!holder_flag;\n      while(Controller1.ButtonL2.pressing())\n      {\n        wait(0.01,seconds);\n      }\n    }\n    holder.set(holder_flag);\n    //======================  Grabber  =======================//\n    if(Controller1.ButtonA.pressing())\n    {\n      grabber_flag=!grabber_flag;\n      while(Controller1.ButtonA.pressing())\n      {\n        wait(0.01,seconds);\n      }\n    }\n    grabber.set(grabber_flag);\n    //======================  Do WallStake  =======================//\n    if(Controller1.ButtonR1.pressing())\n    {\n      if(wallStake_flag)\n      {\n        arm_target = armTakeRing;\n        if (!intakeDone)  \n        {\n          intake_speed = -30;\n          arm_target = armWallStake;\n          wait(0.1, seconds);  \n          intake_speed = 0;\n          intakeDone = true;  \n        }\n        if(Controller1.ButtonR2.pressing())\n        {\n          arm_target = armAllianceStake;\n        }\n        else\n        {\n          arm_target = armWallStake;\n        }\n      }\n      else\n      {\n        arm_target = armLowest;\n      }\n    }\n    else if(Controller1.ButtonR2.pressing())\n    {\n      arm_target = armTakeRing;\n      intakeDone = false;\n      intake_speed = 100;\n    }\n    else\n    {\n      arm_target = armTakeRing;\n      intakeDone = false;\n      intake_speed = 0;\n    }\n    \n    SpeedLeft=(move_speed-turn_speed)/100*12;  \n    SpeedRight=(move_speed+turn_speed)/100*12;\n\n    if (SpeedLeft > maxSpeed) \n    {\n      SpeedLeft = maxSpeed; \n      SpeedRight = maxSpeed - (SpeedLeft - SpeedRight);\n    } \n    else if (SpeedRight > maxSpeed) \n    {\n      SpeedRight = maxSpeed;  \n      SpeedLeft = maxSpeed - (SpeedRight - SpeedLeft);\n    }\n\n    L1.spin(forward, SpeedLeft, volt);\n    L2.spin(forward, SpeedLeft, volt);\n    L3.spin(forward, SpeedLeft, volt);\n    R1.spin(forward, SpeedRight, volt);\n    R2.spin(forward, SpeedRight, volt);\n    R3.spin(forward, SpeedRight, volt);\n  }\n}\nvoid setPID(double sp,double si,double sd)\n{\n  tp=sp;\n  ti=si;\n  td=sd;\n}\nvoid resetPID()\n{\n  tp=0.55,ti=0.0,td=-0.4;\n}\nvoid Auto()\n{\n  arm_flag=armLowest;\n  drive_flag=0;\n  turn_flag=1;\n  targetAngle=-90;\n  Inertial21.setHeading(targetAngle,degrees);\n  wait(0.2,seconds);\n\n  wait(1,seconds);\n}\n\nvoid setup()\n{\n  Inertial21.calibrate();\n  while (Inertial21.isCalibrating()) {\n    wait(100, msec);\n  }\n  targetAngle = 0;\n  Inertial21.setHeading(targetAngle,degrees);\n\n  L1.setVelocity(0, percent);\n  L2.setVelocity(0, percent);\n  L3.setVelocity(0, percent);\n  R1.setVelocity(0, percent);\n  R2.setVelocity(0, percent);\n  R3.setVelocity(0, percent);\n  intake.setVelocity(0, percent);\n  intake2.setVelocity(0, percent);\n  armL.setVelocity(0, percent);\n  L1.spin(forward);\n  L2.spin(forward);\n  L3.spin(forward);\n  R1.spin(forward);\n  R2.spin(forward);\n  R3.spin(forward);\n  armL.spin(forward);\n  intake.spin(forward);\n  intake2.spin(forward);\n  Rotation3.setPosition(0, degrees);\n  L1.resetPosition();\n  R1.resetPosition();\n  thread myThread1 = thread(turnThread);\n  thread myThread2 = thread(armThread);\n  thread myThread3 = thread(displayThread);\n  \n}\n\nint main() \n{\n  setup();\n  wait(1,seconds);\n  Auto();\n  //TestDistance();\n  //Competition.autonomous(TestDistance);\n  Competition.autonomous(Auto);\n  Competition.drivercontrol(Driver);\n  return 0;\n}\n","textLanguage":"cpp","robotConfig":[{"port":[20],"name":"L1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"正","rev":"反","gear":"ratio6_1"},"triportSourcePort":22},{"port":[19],"name":"L2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"正","rev":"反","gear":"ratio6_1"},"triportSourcePort":22},{"port":[18],"name":"L3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"正","rev":"反","gear":"ratio6_1"},"triportSourcePort":22},{"port":[16],"name":"R1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"正","rev":"反","gear":"ratio6_1"},"triportSourcePort":22},{"port":[15],"name":"R2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"正","rev":"反","gear":"ratio6_1"},"triportSourcePort":22},{"port":[14],"name":"R3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"正","rev":"反","gear":"ratio6_1"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[17],"name":"intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[1],"name":"holder","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[21],"name":"Inertial21","customName":false,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[8],"name":"DistanceBack","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[12],"name":"DistanceFront","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2],"name":"armL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"向前","rev":"反","gear":"ratio18_1"},"triportSourcePort":22},{"port":[2],"name":"grabber","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[3],"name":"Rotation3","customName":false,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"true"},"triportSourcePort":22},{"port":[9],"name":"DistanceLeft","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[7],"name":"DistanceRight","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[7],"name":"lift","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[3],"name":"intakeLift","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[6],"name":"endGame","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[5],"name":"HD","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{"id":"partner"},"triportSourcePort":22},{"port":[5],"name":"intake2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}